---
title: 以太坊基本知识
date: 2020-02-22 16:02:33
tags: 区块链
---

## 以太坊

1、改进：

- ETH

- 以太坊出块时间：十几秒；比特币：10分钟

- mining puzzle: 对内存要求高，限制ASIC芯片的使用

- proof of work(工作量证明)---> proof of state(股份投票)
- Smart contract(智能合约): 去中心化的合约

2、去中心化的货币好处：跨国转账

3、智能合约：跨国合约，用技术手段保证合同不违约

4、创始人：Vitalik

5、比特币中Merkle tree不能证明某个交易不存在，sorted 之后才可以

6、没有规定定期减半

7、区块奖励 + gas fee + uncle reward

8、发布一个交易所有全节点都要执行这个交易

9、挖矿是**无记忆**的

10、区块链的安全性是每个全节点验证区块链上的准确性

## 以太坊：账户

1、转账区别：

- 比特币：比特币花钱的时候要说明币的来源, 而且得将剩余的钱转给自己，A->B(10 BTC); B->C(3 BTC), B->B'(7 BTC)，否则7个就成了交易费了
- 以太坊：不用说明币的来源，直接看账户余额 ，对double spending attack有天然的防御作用

2、account-based ledger(以太坊基于账户)缺点：

- reply attack：重放攻击，收钱的人不诚实，希望收两次

- 防范：加计数器，每个账户有花钱的次数

  ![image](https://user-images.githubusercontent.com/17808702/75045435-42f4fe80-54fe-11ea-8560-c273a85573b3.png)

3、账户类别：

- 外部账户：公私钥对控制
  - 账户余额
  - nonce-花钱次数
- 合约账户：不能主动发起交易
  - balance
  - nonce
  - code
  - storage：状态

## 以太坊：状态树

1、以太坊中账户地址：160bit    40个16进制

2、比特币区块大约4000个：1M/250字节

3、账户存储：

- (addr，state)组织成Merkle tree, 这样每次增加都要重新构建，数量级很大，而且所有全节点都要更新
- 排序的Merkle Tree: 每个账户作为叶子结点，插入困难

4、 trie数据结构:

![image](https://user-images.githubusercontent.com/17808702/75084740-2805a700-555d-11ea-97c6-51f8e531649f.png)

特点：只画key

- trie分支数目取决于key值的单词数目，例子中为英文单词，加结束符一共27个所以一个节点的分叉最多为27；以太坊中为16进制+1=17个
- trie的查找效率取决于key的长度(书的深度)，在以太坊中key的长度40个16进制的数
- trie不会出现碰撞
- merkle tree插入的时候得排序，trie插入顺序不同，组成的树相同
- trie更新的局部性好

缺点：

- 存储浪费：一脉单传

5、Patricia tree(Patricia trie): 经过路径压缩之后的trie

![image](https://user-images.githubusercontent.com/17808702/75084891-7ff0dd80-555e-11ea-9cae-733f5b3e17bd.png)

- 新插单词这个树会扩展开
- 键值比较稀疏的时候好

6、modified MPT(Merkle Patric tree)

- merkle proof 能证明账户中有多少钱
- Branch node 7 地方的这个值存的是下面的extension node的hash值
- 每有一个新的区块，有新的区块的状态树，大部分节点是共享的，保留旧的MPT，历史记录，这是为了roll back

![image](https://user-images.githubusercontent.com/17808702/75085155-45d50b00-5561-11ea-96dc-05570c08dd3e.png)

![image](https://user-images.githubusercontent.com/17808702/75085377-6c944100-5563-11ea-83bd-d937eb9f459e.png)

7、block header

![image](https://user-images.githubusercontent.com/17808702/75085388-8f265a00-5563-11ea-88d1-2c9369252730.png)

8、状态树存储的是(key,value)

- value 做序列化之后存储
  - RLP(序列化的库)
  - protobuff

## 以太坊：交易树与收据树

> 交易树与收据书只包含当前区块的交易，状态树则全包含，在当前交易增加一个分支

1、作用：

- 提供merkle proof
- 提供更加复杂的查询操作

2、bloom filter：

- 快速证明集合中是否存在某个元素，将集合中的元素取hash映射到hash表中，新元素取hash在hash表中对照

- 存在误报(false positive), 不存在漏报(false nagitive)

- 不支持删除操作，如果只是0-1，删除元素，没法操作

3、bloom filter作用

- 每个交易完成后形成收据，收据中有bloom filter

- 发布的区块，开头中有总的bloom filer，这个区块的bloom filter的并集
- 查找的时候找块头的bloom filter，找到就往下找交易



## 以太坊：GHOST协议

![image](https://user-images.githubusercontent.com/17808702/75088753-88600d00-558c-11ea-8178-1fce7ed76a06.png)

- 比特币中orphan block：孤儿块，没有成为最长合法链的分叉块；以太坊中叫uncle block
- 给uncle block 7/8 个区块奖励
- 最长合法链上最多有两个uncle block，下一个区块可以包含爷爷的uncle block

问题：

- 新区块出来之后才知道uncle block
- 新区块故意不加uncle block

解决：

- 爷爷，曾祖父也可以为uncle block，但是最多7代以内最多的区块
- 对于新区块包含不管那个辈份的都是奖励1/32个区块奖励(block reward)
- 新区块要查叔父区块的合法性，但是不执行叔父中的交易
- 只有分叉之后的第一个区块给block reward

![image](https://user-images.githubusercontent.com/17808702/75088675-a6793d80-558b-11ea-92e4-e70a9c323351.png)



## 以太坊：挖矿算法

1、名称: ethash

2、ASIC resistance：增加对内存的mining puzzle

3、、以太坊：

- 16M cache, 用于轻节点验证
- 1G dataset, DAG
- 伪随机：seed-->h(seed)-->h(h(seed))....数组

4、代码：

- 生成16M的cache：seed-->h(seed)-->h(h(seed))....数组
- 从cache生成1G的大数据集：读取cache中256个数据，然后取hash得到一个元素
- 根据当前的nonce，读取64个相邻位置的hash组成128个，最后返回hash跟target比较

5、proof of work --> proof of stake

6、算法的设计是为了让通用设备挖矿，参与的人越多越安全

7、有人不这么认为：专用挖矿机的攻击成本会高

## 以太坊：PoS

1、proof of work-比特币耗电量：

- 一年挖矿耗电量：70tWh      1tWh = 10^12Wh      1kWh = 10^3Wh

- 一笔交易耗费1000度电

2、proof of work-以太坊耗电量：

- 一年挖矿耗电量：20tWh
- 一笔交易耗电67度

3、proof of stake

- 给开发人员一部分币奖励
- 给投资人员一部分币奖励
- 根据币的多少投票
- 根据币的权益降低挖矿难度
- 维护安全的资源是个闭环
- 决定新块的方式

4、如何获得最长合法链？

- Casper the Friendly Finality Gadget（FFG）
- Validatir: 投入保证金投票，权重取决于保证金的数量大小
  - 不能两边投票
- 混用下：
  - epoch：每100（优化后50）个出一个
  - Two-phase commit
    - Prepare message    2/3
    - Commit message    2/3
  - 前一个的commit messgae作为下一个的prepare message

![image](https://user-images.githubusercontent.com/17808702/75094386-7b134480-55c5-11ea-8f02-22c3491f3836.png)

## 以太坊：智能合约

1、什么是智能合约？

- 智能合约时运行在区块链上的一段代码，代码逻辑定义了合约的内容
- 智能合约的账户保存了合约的当前运行状态
  - balance
  - nonce
  - code
  - storage：是一个MPT树
- Solidity是智能合约常用的语言

2、如何调用智能合约？

- 外部账户创建一个交易，接收地址为要调用的那个智能合约的地址
- 合约调用另一个合约
- 凡是要接收外部转账的智能合约要定义为payable
- 合约A调用合约B，要在转账交易的data域表明合约B的哪个函数
- 合约账户，A--->B缺省函数, 默认调用B的fallback()函数

3、gas fee:

- 执行合约中的指令要收取gas fee, 发起交易的人支付

4、交易有原子性：要么执行完，要么不执行

- 执行到一半，gas fee不退回
- A-->B, B失败，根据调用方式决定A是否会滚

5、block header 中的 gas limit: 可以通过上一个的基础上进行上调或下调     1/1024

6、汽油费如何扣除？

- 全节点维护3棵树，收取汽油费的时候只是在本地状态树中的账户余额扣除
- 只有在本地修改完了，发布到区块链上才能变成共识
- 先执行完区块中的全部交易更新三棵树，更新blocke header，再发布，获得汽油费
- 执行交易，智能合约的全节点但是没有发布的，没有补偿，还要根据链上新区块更新自己的三棵树
- 执行智能合约出错的也要发布，扣汽油费

7、Solidity不支持多线程原因：

多核对内存调用顺序不同结果使不同的，但是区块链是一个交易驱动的状态机，同样的输入必须同样的输出

8、转账：

- tranfer() 会导致连锁回滚
- send() 不会连锁回滚
- call().value() 不建议

9、简单例子：拍卖

- 拍卖出价向智能合约中存以太币，且不允许取出

10、code is law----代码发布上去就不可更改，发布之前要测试测试测试

## 以太坊：The DAO

> Decentralized Autonom Organization 去中心化的自治组织

1、什么是The Dao？

是Dao的一个组织：众筹投资组织，使用以太币换取投资权

2、split DAO：

- 成立子基金，使得投资者取回投资的唯一途径(自己投资自己)
- 先把账户清零再转账
- 被黑了1/3以太币，但是有28天的锁定期

3、普通回滚，即分叉攻击没有用

4、措施

- 升级，凡是跟the DAO相关账号的相关的交易等于非法
  - 软分叉
  - 升级之后，要判断是不是跟the DAO相关，要不要收gas fee？
    - 没有收gas fee
    - 结果升级之后不停的收到这个gas fee的攻击
- 升级，the Dao账户的资金强行到新的智能合约
  - 硬分叉
  - 投票，升级之后
    - 新链 ETH(被强制执行了)
    - 旧链 ETC
  - 增加chainID分开



## 以太坊：反思

1、智能合约真的智能吗？

Smart contract is anything but smart

2、不可篡改性是个双刃剑

- 账户私钥公开之后怎么办？
  - 将钱转走

3、没有什么是不可篡改的

- 美国宪法修正案
  - 不能喝酒

4、Solidity 是正确的编程语言吗？

- 从语言设计的角度，Solidity够呛
- Solidity是图灵完备的语言
- 使用模板写合同

5、Many eyeball fallacy(misbelief)

- 虽然开源，但是不一定安全，有多少人看，又有多少人懂

6、去中心化意味着什么？

- 去中心化对规则的修改也要用去中心化的手段去解决
- 分叉恰恰是去中心化的体现

7、去中心化系统不等于分布式

- 去中心化系统是分布式的
- 分布式的系统不一定是去中心化的
- 在互不信任的网络中建立共识

## 以太坊：美链

> Beauty Chain

1、ICO：Initial Coin Offering

- 以太坊的代币，通过智能合约函数完成
- ERC 20(Ethereum Request fot comments)是以太坊发行代币的一个标准

2、bug：从总账户中扣代币，给其他每个账户分发

- amount = receivers.length * value
- 扣钱(amount)，循环发钱（value）
  - amount 可能溢出，成为一个很小的数值

3、被回滚了

4、判断合法运算：

- c = a*b(a,b 为256位的整数)
- assert(c / a, b)

