---
title: 南大自动打卡
date: 2021-02-02 23:41:37
tags:
---



### 南大自动打卡脚本

> 脚本基于chrome和selenium，模拟浏览器点击

项目用于学习交流，仅用于各项无异常时打卡，建议如实打卡。

与北航自动打卡脚本不同，本脚本需三步：

- 第一步，selenium登陆获取某个权限信息（时间关系，不深究是那个cookie了，准备春招了）

  > 通过抓包获取到app里面的请求可知，打卡相关为两个请求 getAppInfo/postAppInfo

- 第二步，由于自动打卡内部每天会自动写一份数据自带一个WID作为post的输入，所以访问getAppInfo拿到WID

- 第三步，直接调用post将信息传入即可

#### 功能列表：

- 自定义定位
- 检测登录是否成功和网页能否打开
- 定时自动打卡*
- 微信推送打卡结果**
- 日志记录

```python
import json
import logging
from time import sleep
import time
import datetime
import requests
from selenium import webdriver  # 导入webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains


user = '***'  # 你的统一认证账号
passwd = '***'  # 你的统一认证密码
current_url = 'https://authserver.nju.edu.cn/authserver/index.do'  # 登陆成功跳转链接
get_app_info_url = 'http://ehallapp.nju.edu.cn/xgfw/sys/yqfxmrjkdkappnju/apply/getApplyInfoList.do'
post_app_info_url = 'http://ehallapp.nju.edu.cn/xgfw/sys/yqfxmrjkdkappnju/apply/saveApplyInfos.do'
SCKEY = ""  # 微信推送api，到http://sc.ftqq.com/ 免费申请，不需要请留空
set_time = [(8, 17)]  # (小时，分钟)， 如果多个时间可以写成[(h, m),(h, m)]的形式
max_attempt = 5  # 失败重复五次

data = {
    "WID": "",
    "CURR_LOCATION": "", # 中国江苏省南京市鼓楼区小粉桥
    "IS_TWZC": 1,
    "IS_HAS_JKQK": 1,
    "JRSKMYS": 1,
    "JZRJRSKMYS": 1
}




def daka():
    login_flag, browser = login()
    if not login_flag:
        return

    browser.get(get_app_info_url)
    get_info_str = browser.find_element_by_tag_name('pre')
    get_info_json = json.loads(get_info_str.text)
    data['WID'] = get_info_json['data'][0]['WID']
    logger.info("成功获取WID")
    time.sleep(3)
    post_url = post_app_info_url + '?'

    for i in data:
        post_url += str(i) + '=' + str(data[i]) + '&'
 
    browser.get(post_url)
    post_info_str = browser.find_element_by_tag_name('pre')
    post_info_json = json.loads(post_info_str.text)

    if post_info_json['code'] == str(0):
        logger.info("成功打卡")

    sleep(40)
    browser.quit()
    datee = datetime.date.today()
    send_message("小主打卡成功")
    logger.info(str(datee) + " 流程结束")


def login():
    chrome_options = Options()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument('--no-sandbox')
    browser = webdriver.Chrome(options=chrome_options)

    try:
        url = "https://authserver.nju.edu.cn/authserver/login"
        browser.implicitly_wait(10)
        browser.get(url)

        # # 账号密码
        user_name_input = browser.find_element_by_id('username')
        user_name_input.send_keys(user)
        user_pwd_input = browser.find_element_by_id('password')
        user_pwd_input.send_keys(passwd)

    except:
        logger.info("打开打卡网页失败，请确认网络")
        send_message("打开打卡网页失败，请确认网络")
        return False, None

    logger.info("成功打开打卡网页")

    # 点击登录按钮
    login_button = browser.find_element_by_css_selector('.auth_login_btn.primary.full_width')
    ActionChains(browser).move_to_element(login_button).click(login_button).perform()
    browser.implicitly_wait(5)

    # 跳转并点击获取位置按钮
    # 这样写是为了等待跳转页面加载出来
    fail_cnt = 0
    while True:
        # browser.current
        # location_button = browser.find_element_by_id('saveall')
        if browser.current_url == current_url:
            logger.info("登录成功")
            return True, browser
        else:
            # 出现密码错误提示框
            if len(browser.find_element_by_id('msg')) > 0:
                send_message("打卡失败，用户名密码错误，程序已退出，请检查")
                logger.info("打卡失败，用户名密码错误，请检查")
                exit(0)

            # 若只是反应慢，重试
            if fail_cnt >= max_attempt:
                send_message("登录超时超过最大尝试次数，请检查网络或打卡系统已崩溃")
                logger.info("登录超时超过最大尝试次数")
                return False, None
            time.sleep(10)
            browser.get("https://authserver.nju.edu.cn/authserver/login")
            logger.info("登录超时，正在重试")
            fail_cnt += 1


def main():  
    logger.info("正在进行验证...")
    flag, browser = login()  # 测试能否进入网页以及用户名密码是否正确
    time.sleep(3)
    browser.quit()
    logger.info("时间未到，等待打卡")
#    daka()
    if not flag:
        exit(0)
    while True:
        while True:
            # time_up = True  # debug
            time_up = False
            now = datetime.datetime.now()
            for hour, minute in set_time:
                if now.hour == hour and now.minute == minute:
                    time_up = True
            if time_up:
                break
            logger.debug(f"时间未到，当前时间 {now}")
            sleep(20)
        logger.info("时间已到，正在打卡")
        daka()


def send_message(msg):
    if SCKEY == "":
        return
    payload = {'text': msg}
    requests.get(f"https://sc.ftqq.com/{SCKEY}.send", params=payload)


if __name__ == "__main__":
    log_file = "log.log"
    formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")
    logger = logging.getLogger("main")
    fh = logging.FileHandler(log_file, mode='w')
    fh.setFormatter(formatter)
    ch = logging.StreamHandler()
    ch.setFormatter(formatter)
    logger.addHandler(fh)
    logger.addHandler(ch)
    logger.setLevel(logging.INFO)
    main()

```

